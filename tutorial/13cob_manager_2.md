<!--
 * @Coding: utf-8
 * @Author: vector-wlc
 * @Date: 2021-09-25 17:34:09
 * @Description: 
-->
# 炮管理类——多炮列表

上一篇文章中我们知道了炮管理类中最基本的接口，这篇文章我们将讨论如何使用炮管理类创建多个炮列表。
首先我们需要知道为什么需要多炮列表，是因为在处理天台这样的场景时，由于 PvZ 的一个 BUG(上界之风)，
导致不同列炮的飞行时间和落点偏移都不相同，如果将这些炮都放在一个炮列表中使用，那调炮序就会把人调麻了，
所以多炮列表应运而生

创建多个炮列表语法：

```C++
ACobManager windCob; // 风炮
ACobManager groudCob; // 平地炮

void AScript(){
 
}
```

**请注意在创建多个炮列表时，必须将炮列表定义为全局对象，即定义在函数 `void AScript()` 外部**，这点十分重要，如果定义在 `AScript` 函数内部，会为以后的使用带来不必要的麻烦。下面我们结合具体的例子说明多炮列表的意义。

RE 十炮：

![RE 十炮](./img/RE10.jpg)

对于此阵，由于风炮（位于一列的炮）和平地炮（位于六列的炮）的落点偏移不同驱使着我们必须将平地炮发往四行，将风炮发往二行，否则会导致漏炸。所以此时如果我们使用一个炮列表则必须刻意的对炮的使用顺序进行设计，但是多炮列表就解决了这个麻烦，接下来我们看多炮列表是如何做到的。

```C++
windCob.SetList({{
    {1, 1},
    {2, 1},
    {3, 1},
    {4, 1},
    {5, 1},
}});
 // 风炮
groudCob.SetList({{
    {1, 6},
    {2, 6},
    {3, 6},
    {4, 6},
    {5, 6},
}});
```
 // 风炮
windCob  // 平地炮此时储存着风炮所在的位置，groudCob 储存着平地炮所在的位置，由于是天台，这里我们使用 `RoofFire` 函数，此时只要使用对应的炮操作对象调用 `RoofFire` 函数就可以使用相应位置的炮。
```C++
windCob.RoofFire(2, 9);
groudCob.RoofFire(4, 9);
```

这样我们就保证了发射的一对炮里必是一个来自平地炮一个来自风炮的，并且平地炮必射向四行九列，风炮必射向二行九列，这样就不用刻意设计炮位置的书写顺序了。


[目录](./0catalogue.md)

