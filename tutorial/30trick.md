
# 一些编写技巧

本篇文章主要是介绍如何使用 C++ 中的**宏和运算符重载**来简写脚本代码。

AvZ2 的设计目标是写出更不容易出现运行时问题的代码，并且为了保持接近传统 C++ 代码的风格，
基本没有使用"魔法"来简写代码，因为我本人认为这可能会增加学习成本并且可能会降低代码的可读性。
毕竟大规模使用宏和运算符重载会使得代码变得非常奇怪。当然合理使用宏和运算符重载不仅不会降低代码可读性，
反而会提高可读性，达到事半功倍的效果，本篇文章接下来的例子是列举我本人认为一些比较好的使用例子，
最希望的是能够抛砖引玉，能让使用者本身会使用上述两大工具降低自己的代码编写工作量。

## 宏

首先介绍一下宏是什么，宏可以简单的理解为文本替换，接下来举三个最常用的例子

```C++
// 定义一个宏 A，代码中出现 A 的地方就会被 1 替换，注意是文本直接替换
#define A 1       

int var = A;  // 将 var 初始化成 1
```

```C++
// 定义一个带参数的宏 B，实现两数相加的功能
#define B(a, b) (a + b)

int var = B(1, 2); // 这条代码等效为 int var = (1 + 2);
```

注意上述代码中 (a + b) 的小括号是必不可少的，因为宏是文本替换，假如遇到下面这个情况

```C++
int var = B(1, 2) * 3;
```

有没有括号的结果是天差地别的

```C++
// 有括号
int var = (1 + 2) * 3; // var = 9

// 无括号
int var = 1 + 2 * 3; // var = 7
```

所以时刻记住: **宏是文本替换**。接下来介绍最后一种常用的使用情况

```C++

// 定义一个宏C
#define C(a, ...) a + __VA_ARGS__

int var = C(1, 2 + 3); // 等效为 int var = 1 + 2 + 3;
int v = C(1, 2 * 3); // 等效为 int v = 1 + 2 * 3;
```

在宏中，`...` 中的内容是啥，`__VA_ARGS__` 就是啥。至于为啥是`__VA_ARGS__` 而不是别单词的，这是宏规定的，没有为什么，在宏中，还有 `# 和 ##` 两个东西，
其使用规则自行网上查找，在此不在赘述。

在理解了宏的使用之后，咱们可以使用这个东西做很多有意思的东西。

例如以下代码

```C++
AConnect(ATime(1, 2), [] { ACard(1, 2, 3); });
```
有些人抱怨上面代码写的非常繁琐，此时咱们就可以使用宏来简写一些代码。

例如定义一个宏 L
```C++
#define L(...) [] { __VA_ARGS__; }
```

有了这个宏之后，代码就可以变成这样
```C++
AConnect(ATime(1, 2), L(ACard(1, 2, 3)));
```

可以看到使用了宏之后代码就变得稍微简单了一些。咱们可以再进一步整一下
```C++
#define Connect(wave, time, ...) AConnect(ATime(wave, time), L(__VA_ARGS__));
```

有了这个宏，代码就变成了
```C++
Connect(1, 2, ACard(1, 2, 3)); 
```

可以看到代码变得更简单了，上面这个宏还可以这么用

```C++
Connect(1, 2, ACard(1, 2, 3); aCobManager.Fire(2, 9));

// 上述代码等效为
AConnect(ATime(1, 2), [] { ACard(1, 2, 3); aCobManager.Fire(2, 9); });
```

乍一看是不是挺奇怪的（至少你没见过函数参数里面有个分号吧），这个就是宏的副作用，它在一定程度上会简写代码，但是可能会降低代码的可读性。


为了进一步简写代码，咱们可以定一个 Card 宏

```C++
#define Card(wave, time, ...) AConnect(ATime(wave, time), [] { ACard(__VA_ARGS__); });

Card(1, 2, 1, 2, 3); // 等效为 AConnect(ATime(1, 2), [] { ACard(1, 2, 3); });
```

我相信通过上面几个例子大家应该明白使用宏这个东西会带来咋样的作用了。如果合理利用他会让你脚本编写的工作事半功倍。


## 运算符重载

运算符重载是另一个大杀器，合理利用同样事半功倍，但是这个东西涉及到的语法比较复杂，在此不再赘述，有兴趣的可以自行网上了解学习，
这里是为了介绍 **运算符重载和 ARelOp** 配合使用，ARelOp 忘了是啥玩意的童鞋可以转步 [连接再探] 中的
"ARelOp (相对操作)" 小节，这两种的结合使用已经有一个插件做到了，他就是 : https://github.com/qrmd0/AvZLib/tree/main/Reisen/AvZDSL ，使用这个插件可以达到极度压缩代码量的目的，熟练之后代码可读性也比较好。下面就是一个使用例子：

```C++

// 这里定义的 ARelOp 可以说是一次定义，多次使用
ARelOp N = ARelOp(-100, [] { ACard(ALILY_PAD, {{3, 9}, {4, 9}, {3, 8}}); }) +
           ARelOp(-100, [] { ACard(ADOOM_SHROOM, {{3, 9}, {4, 9}, {3, 8}}); });

ARelOp P = ARelOp(-373, [] { aCobManager.Fire({{2, 8.75}, {5, 8.75}})); });

// 第 (2 6) 和 (3 7) 波进行下面的操作 
"2-9+4 3-9+4"_wave[
    11_cs[N],
    1976_cs[-200_cs[P]]
    // N 在 11cs 生效，PP 在 1776cs 生效
];

// 第 4, 8, 13, 17 波进行下面的操作 
"4, 8, 13, 17"_wave[
    1200_cs[N] // 1200 cs 核生效
];
```

可以看到使用这个插件可以降低非常多的代码量，熟练使用之后会提高脚本编写速度。


