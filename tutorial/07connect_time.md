<!--
 * @Coding: utf-8
 * @Author: vector-wlc
 * @Date: 2022-11-18 19:10:57
 * @Description:
-->
# 时间管理: 连接

首先说明一下，`AConnect`(连接)是本框架的核心功能之一，它可用于但不限于时间，
考虑到大家一下接受不了那么多东西，这里就仅仅给大家介绍他关于时间方面的功能，

还是接着阻塞往下说吧，比如我想实现 在 (1, -599) 也就是游戏一开始的时候(第一波，僵尸刷新前 599cs)将寒冰菇种在一行一列，在 (1, 0) 的时候发一门炮 这样的需求，那 `AConnect` 怎么写呢，答案就是：

```C++

void FireCob(){
    aCobManager.Fire(1, 1); // 此行代码将会调用一门炮发送到一行一列
}

void UseCard(){
    ACard(AICE_SHROOM, 1, 1);
}

void AScript(){
    AConnect(ATime(1, 0), FireCob);
    AConnect(ATime(1, -599), UseCard);
}

```

emmm, 不知道大家是不是能看懂，首先看 void AScript() 函数体的第一行， AConnect 的第一个参数是一个时间点，ATime(1, 0) 这个大家应该很好理解，
那么第二个是啥玩意，实际上是个函数名，那 FireCob 这个函数干了什么？ 就是调用了一下发炮函数，那实际上第一行的意思就很清楚了，
就是建立了一条连接，这个连接有啥用呢，这个连接承诺当时间点到达 (1, 0) 的时候，调用 FireCob 这个函数，那 FireCob 这个函数
又会调用  aCobManager.Fire(1, 1); 所以就实现了和阻塞类似的功能，第二行代码我就不解释了。我们可以很明确的看到，我没有按照时间点的先后顺序写
AConnect，那他会正确运行吗？我可以很明确的告诉你，能！他能！因为他是创建了一条连接，而不是阻塞了脚本的运行，这条连接创建是一瞬间的事，
那你又有疑问了，那这条连接是啥时候创建的呢？**记住 void AScript() 这个函数是在脚本从游戏选择生存模式的那个界面点到选卡或者战斗界面的那一帧调用的**，因此这个连接也就在刚进入选卡或者战斗界面的时候被创建了，连接创建之后本框架宝宝就会时刻监视每一条连接，如果这个连接的触发条件满足，就会运行连接所对应的操作，所以**连接允许你随意书写代码顺序，不必像阻塞那样计算哪个时间点靠前还是靠后**

那么此时你就会有疑问，能不能这么写：（这不就不用新写一个函数那么麻烦了吗？）
```C++
    AConnect(ATime(1, 0), aCobManager.Fire(1, 1));
```

**emmm, 我可以很明确的告诉你，不能，因为这并不是让 AConnect 去连接 aCobManager.Fire(1, 1) 这个操作，而是连接这个操作完成之后的返回值**，
就像我正确代码中写的是 FireCob，而不是 FireCob(), 如果你无法理解这句话那就死记硬背，先记下来，先用着正确的方式，慢慢的你就理解了，没办法，学习新知识有的时候就是这样的。

在这里我详细的解释一下，下面的解释的话你可能暂时理解不了，但是你总有一天会理解。

AConnect 的第二个参数接收一个可调用对象，这个可调用对象现在说的就比较抽象了，在 C++ 里面可调用对象大致分为三类
* 函数指针 (FireCob UseCard 就是函数指针)
* Lambda 表达式 (就是接下来即将介绍的)
* 重载了 operator() 类的对象 (实际上这是 Lambda 的原理，但是大家这里不需要掌握这个玩意)
 

好了，如果你能看懂我上面的解释，就知道为啥填 `aCobManager.Fire(1, 1)` 不行了，因为 `aCobManager.Fire(1, 1)` 返回值为 int 类的对象(变量)，很明显他不是一个可调用对象，所以不能这么写; 但是上面的话你如果看不懂，那就当我装了个逼，咱们接着说后面的部分。

这时屏幕前的你就站出来了，说，真麻烦，合着每次用连接我还得写个函数啊，我还是回去用阻塞吧，但是，你先别急，连接还有一种较为简洁的调用方式，
咱们这个框架用的 C++ 标准是 C++20, 这个标准非常牛逼，他支持 `Lambda 表达式`（实际上 C++11 标准就支持了），那么 Lambda 表达式是个啥玩意呢，
咱们直接上代码吧。


```C++
void AScript(){
    auto fireCob = []{
        aCobManager.Fire(1, 1); // 此行代码将会调用一门炮发送到一行一列
    };

    auto useCard = []{
        ACard(AICE_SHROOM, 1, 1);
    };
    AConnect(ATime(1, 0), fireCob);
    AConnect(ATime(1, -599), useCard);
}

```

这个代码就用到了 Lambda 表达式，你发现他好像是一个定义在 AScript 内部的函数，而且还是有个名字 fireCob 和 useCard，但是为了偷懒，我们可以不用这些名字，实际上 Lambda 还有一种说法就是匿名函数，其实就是没有名字的函数，咱们看下面的代码就更清晰了。

```C++
void AScript(){
    AConnect(ATime(1, 0), []{
        aCobManager.Fire(1, 1); // 此行代码将会调用一门炮发送到一行一列
    });
    AConnect(ATime(1, -599), []{
        ACard(AICE_SHROOM, 1, 1);
    });
}

```

这个时候再看代码，你就发现确实没名字了，这样书写是正确的，可以这样理解，Lambda 有一个返回值，他需要被一个变量接收，之前的示例使用了 fireCob 和 useCard 进行了接收，但是现在，**直接使用了 AConnect 的形参进行了接收**，这样看着简洁了很多，实际上这才是咱们大多数情况下使用 AConnect 的姿势，如果你实在理解不了这个变化过程，我还是那句话，如果你无法理解这句话那就死记硬背，先记下来，先用着正确的方式，慢慢的你就理解了，没办法，学习新知识有的时候就是这样的。

实际上你还是会说，这看着不如阻塞好看懂，是的，连接的可读性确实不如阻塞，但是你不用为了时间点的先后书写顺序发愁了啊，有得必有失嘛，慢慢适应，当你适应了 AConnect 的这种书写方式，你就会觉得 AConnect 真香，yyds !!!

最后再说明一下，你可能疑惑，Lambda 表达式中的 [] 是啥意思，实际上这是一个捕获列表，在本框架下这个东西填一个 [] 也就是空捕获列表就行，少数情况下需要用 [=] 也就是按值的拷贝方式捕获外部变量，emmm 这怎么理解呢，看下面的代码

```C++
void AScript(){
    int a = 1;

    // 比如我想在这个 Lambda 表达式用这个 a
    // 那需要写成 [=]，而不是 []
    AConnect(ATime(1, -599), [=]{
        // 这时候就可以用 a 了
        // 但是注意，这个 a 是外部的那个 a 的拷贝，而不是其本身
        // 并且不能改变这个 a 的值
        // 因为 lambda 默认使用 const 捕获
        ACard(AICE_SHROOM, a, 1);
       
    });

    // 如果你需要使用外部变量，并且对其值进行修改
    // 需要在 [=] 后面加上 () mutable
    AConnect(ATime(1, -599), [=]() mutable{
        // 这时候就可以用 a 了，并且可以对 a 进行修改
        // 但是依然需要注意这个 a 是拷贝，不是引用
        // 如果改写这个 a 是不会影响到外部的 a 的
        // 那你这时候又会有疑问，我如果想改变外部的哪个 a 怎么办？
        // 在本框架中如果发生了这种情况，我建议你使用全局变量，而不是引用捕获
        // 如果你实在还想问引用捕获是什么，请利用你的浏览器吧
        a = 2;
        ACard(AICE_SHROOM, a, 1);
       
    });
}
```


[目录](./0catalogue.md)