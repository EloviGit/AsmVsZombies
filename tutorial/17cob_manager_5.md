<!--
 * @Coding: utf-8
 * @Author: vector-wlc
 * @Date: 2021-09-25 18:45:59
 * @Description:
-->

# 炮管理类——炮序排布

回到炮管理类设计之初要解决的问题——炮序排布。炮管理类内置了一些调整炮序的函数：

```C++
// 时间模式/空间模式：

// 跳过炮列表中的两门炮
aCobManager.Skip(2);
// 将炮列表中位于二行三列中的炮设置为下一门即将发射的炮
aCobManager.SetNext(2, 3);
// 将炮列表中的第一门炮设置为下一门即将发射的炮
aCobManager.SetNext(1);

// 优先级模式：

// 把位于 2-3 的炮的优先级设为最高
aCobManager.MoveToListTop(2, 3);
// 把位于 1-1、2-1 的炮的优先级设为最低
aCobManager.MoveToListBottom({{1, 1}, {2, 1}});
```

由于不同模式的发炮逻辑不同，炮序调整函数**不互通**，使用与炮序模式不符的函数会报错。

接下来分几种情况讨论：

## 非天台场景

在非天台场景，不同位置的炮之间并没有本质差别。如果无需铲种，一个炮列表就可以应对所有情况。

### 原地铲种 + 不关心铲种位置

这种情况推荐大家使用 时间使用模式 + `FixLatest` 的组合，由于不关心铲种位置，这种组合可以说是最适合这种情况的了，可以省去几乎所有的麻烦。

### 关心铲种位置

这种情况下使用 `FixLatest` 就比较勉强甚至不可用了（比如需要位移铲种的情形），推荐使用优先级模式。既然我们要指定某炮在某时间发射，那么就在炮列表里把这门炮的优先级降到最低（这样炮管理类就会优先使用其他的炮，把这门炮空出来），在预定的时间点再把它的优先级调回最高即可。写成代码就是这样：

```C++
// 出怪、选卡等等

aCobManager.SetSequentialMode(ACobManager::PRIORITY);
aCobManager.MoveToListBottom(1, 1); // 假设要铲种 1-1 的炮

// 其他操作

// 假设要在这个时间铲种
AConnect(ATime(3, 225 - 373), [] -> ACoroutine {
    aCobManager.MoveToListTop(1, 1);
    aCobManager.Fire(2, 9);
    co_await 205; // 炮发射 205cs 之后可以铲除
    AShovel(1, 1);
    aCobManager.Plant(1, 1);
})
```

## 天台场景

当场景为天台场景时，多炮列表的存在就变的有意义了。在原版的天台场景中，玉米加农炮的飞行时间和落点会随着炮所在列数发生波动，因此如果只使用一个炮列表会使得炮序排布变得非常困难。

### 按列划分

这是最基本的一种划分炮列表的方式。以这个阵型为例：

![RE 18](./img/RE18.jpg)

我们可以这样做:

```C++
// 分配四个炮列表，分别是
ACobManager col1, col3, col5, col7;

void AScript(){
    // 为其分配炮
    col1.SetList({{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1}});
    col3.SetList({{1, 3}, {2, 3}, {3, 3}, {4, 3}, {5, 3}});
    col5.SetList({{1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}});
    col7.SetList({{1, 7}, {2, 7}, {3, 7}});
}
```

这样我们使用相应的对象调用相应的炮函数就可以发射相应位置的炮了。这种方法永远不会出错，但代价是需要脚本编写者提前设计好完整的炮序，编写和修改都很麻烦。

### 按风炮、平炮划分

如果阵型对炮落点的要求不是很苛刻，也可以把炮列表简化为两个：

```C++
ACobManager slope, flat;

void AScript(){
    slope.SetList({{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1},
                   {1, 3}, {2, 3}, {3, 3}, {5, 3}, {5, 3}});
    flat.SetList({{1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5},
                  {1, 7}, {2, 7}, {3, 7}});
}
```

### 两用炮

3 列炮和 5 列炮往往既可以当作风炮用，也可以当作平炮用。但是，如果简单粗暴地让 `slope` 包含 1、3、5 列炮，`flat` 包含 3、5、7 列炮，会带来一个问题：这两个炮列表可能会放着“专属”的 1 列和 7 列炮不用而去抢两用炮，这显然是我们不希望看到的。可以使用优先级模式解决这个问题：

```C++
ACobManager slope(ACobManager::PRIORITY), flat(ACobManager::PRIORITY);

void AScript(){
    // slope 优先用 1 列，其次用 3 列，最后用 5 列
    slope.SetList({{1, 1}, {2, 1}, {3, 1}, {4, 1}, {5, 1},
                   {1, 3}, {2, 3}, {3, 3}, {5, 3}, {5, 3},
                   {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5}});
    // flat 反过来，优先用 7 列，其次用 5 列，最后用 3 列
    flat.SetList({{1, 7}, {2, 7}, {3, 7},
                  {1, 5}, {2, 5}, {3, 5}, {4, 5}, {5, 5},
                  {1, 3}, {2, 3}, {3, 3}, {5, 3}, {5, 3}});
}
```

当然，这种方法也不是万能的，有时仍然需要人工干预炮序。

## 智能炮序排布

在一些更为复杂的情境下，我们可能希望脚本在运行时动态决定发炮逻辑。炮管理类提供了几个获取炮冷却信息的函数：

```C++
// 得到可用的炮的内存指针
auto cobPtr = aCobManager.GetUsablePtr();

// 得到发往九列可用的屋顶炮的内存指针
auto cobPtr = aCobManager.GetRoofUsablePtr(9);

// 得到恢复时间最短的炮的内存指针
auto cobPtr = aCobManager.GetRecoverPtr();

// 得到发往九列恢复时间最短的屋顶炮的内存指针
auto cobPtr = aCobManager.GetRoofRecoverPtr(9);

// 得到 1-2 列的屋顶炮发往 7 列飞行的时间
auto flyTime = ACobManager::GetRoofFlyTime(1, 7);

// 得到恢复时间列表
// 如果恢复时间为 -1，代表炮被锁了不可用
// 如果恢复时间为 INT_MIN，代表炮消失了
// 恢复时间 >= 0 为正常值
auto lst = aCobManager.GetRecoverList();
for (auto&& [ptr, recoverTime] : lst) {
   // 这里应该写相应的处理代码
   // 示例就打印一下算了
   logger.Info("指针: #, 恢复时间: #", ptr, recoverTime);
}
```

炮序排布的方法有很多，而且并没有绝对的好坏。上面的内容只是基于作者的个人观点，有不同意见欢迎讨论。

[目录](./0catalogue.md)
