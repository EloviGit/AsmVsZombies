<!--
 * @Coding: utf-8
 * @Author: vector-wlc
 * @Date: 2023-01-16 16:07:34
 * @Description:
-->
# (附加) 两仪键控

**请强烈注意，我不是键控技术党，我是键控工具党，所以示例脚本的目的是教会大家如何使用本框架的接口，**
**脚本中的一些数值并不是科学的数值，科学的数值请询问当前植吧顶尖技术党或者查看相关的帖子和B站动态等，但由于本人早已不是键控技术党，**
**而且没有精力和兴趣去学相关的键控技术知识。**

**所以不要把示例脚本视作完美无缺的，而只是把他视作学习本框架接口的工具**

**所以不要把示例脚本视作完美无缺的，而只是把他视作学习本框架接口的工具**

**所以不要把示例脚本视作完美无缺的，而只是把他视作学习本框架接口的工具**

是的，你没看错，两仪键控教程他来了，**其实这也不算是教程，而更像一种心得分享，注意，我还是那句话，下面的分析以及代码并不是最优的，因为我根本不会手控，但是其提供了键控无炮的思路和 AvZ 接口的使用。**

温馨提示：这个教程是一个附加教程，想了解如何键控无炮的玩家请接着往下看，不然可能看的怀疑人生。

见 [两仪无炮脚本](./scripts/liang_yi/liang_yi.cpp)

## 中心思想

实际上键控无炮大致思路可以归为一点：将自己看到的和要操作的告诉电脑，没错，就是这一句话。
要完成上面那句话，我认为至少需要具备两点:
1. 需要具备手控经验，这样才能知道看什么和做什么，
2. 需要具备一定的编程能力，这样才能把上面两个什么转化为代码，以告诉电脑咱们的想法。

## 看什么

对于手控无炮来说，运阵时咱们需要看什么？那当然是看对阵型有威胁的僵尸，比如两仪，对阵型有威胁的僵尸都有啥？
1. 红眼：毋庸置疑，红眼是对两仪威胁最大的僵尸，这是必看的。
2. 小丑：小丑僵尸不会有进家威胁，但是他可能会炸掉灰烬垫材，因此需要注意。
3. 气球：此僵尸虽然很弱鸡，但是有进家威胁，需要观察并使用三叶草处理。
4. 冰车：这个东西没有进家威胁，但是其会碾压垫材，因此需要注意。
5. 橄榄：这玩意又快又肉，出现在边路如果没有灰烬处理有很大的进家威胁。

好了僵尸的种类基本分析完了，那咱们怎么让电脑看到这些僵尸的信息呢？其实就是用一个东西，把这些僵尸的信息存在这个东西里面，
等到在做什么阶段的时候直接让代码遍历这些信息就行。在这里，我们将这个东西定义为容器。实际上游戏中就自带了这样一个容器，也就是僵尸数组，他存储了所有的僵尸信息，那这样一看好像不用我们人为的创建容器了，是的，这种想法没有啥大问题，但是在写代码的过程中，
这种直接遍历僵尸数组的做法可能不是很好，为什么？因为代码一帧内要做的事情可能非常多，比如：用倭瓜，用樱桃，用三叶草，用垫材，用辣椒，
上述操作基本都需要遍历红眼的位置信息，有些还要遍历小丑，冰车和气球的，因此这就相当于一帧之内重复遍历了五次一模一样的僵尸数组，
虽然现代 CPU 性能确实获得了大幅提升，而且一帧内遍历个几十次甚至上百次僵尸数组游戏依然不会有卡顿，但是这样做我认为并不是很好，因为遍历了太多无用的僵尸，就是做了很多无用功，代码中会有大量的 if else 或者 switch case 增加缩进深度，所以演示脚本中并没有这样做，下面说明一下我是怎么做的 (不要将这种做法作为一种规范，因为可能会有更好的做法)

1. 对于红眼，脚本中使用了一个大小为(6 * 9)的二维数组以每格的精度记录红眼的内存指针，这里可能有一个更好的容器选择，那就是哈希表，因为咱们知道水路是不可能出红眼的，但是我没有用哈希表，只是用了一个二维数组，因为看似普通数组直接浪费了两行的位置内存，但是哈希表可能更加浪费内存。
2. 对于小丑，由于其每波存活数量不是很多，咱们没必要大费周折还整一个二维数组去记录每个格子的小丑指针，因此直接整一个可变数组记录全部小丑的指针。
3. 对于气球，咱们只会关注最靠左的气球，其他的会忽略，因此只需要一个变量记录就行。
4. 对于冰车：同小丑
5. 对于橄榄：橄榄这个东西据说操作得当是几乎没有威胁的，实际上就是使用 8 列核的时候可能会漏 (这是我认为的，不保证正确，漏了不要打我)。因此在脚本中做了一些特殊处理，以保证不会让灰烬漏边路橄榄(漏了不要打我)，因此脚本中并没有特殊记录橄榄的信息。以下就是相关代码

```C++
// AvZ2 C++ 代码
for (auto&& zombie : aAliveZombieFilter) {
    switch (AZombieType(zombie.Type())) {
    case AHY_32: {
        // 这里 -11 是为了垫材好放置
        // 红眼最左垫材锤击第 x 格垫材满足以下公式
        // x = (红眼横坐标 - 11) / 80 + 1
        int col = (zombie.Abscissa() - 11) / 80;
        col = std::clamp(col, 0, 8);
        _gigaVec.At2d(zombie.Row(), col).push_back(&zombie);
        break;
    }
    case AQQ_16: {
        _minBalloonX = std::min(_minBalloonX, zombie.Abscissa());
        break;
    }
    case AXC_15: {
        _boxZombieVec.push_back(&zombie);
        break;
    }
    case ABC_12: {
        _zomboniVec.push_back(&zombie);
        break;
    }
    default: {
        break;
    }
    }
}
```

## 做什么

做什么实际上就是操作决策，在手控中就是如果僵尸怎么怎么样，那么咱们就如何如何操作，这个部分大家会发现每个人的想法可能都有一些不同，
这里说明一下我的决策思路，由于我几乎没有任何手控经验，遇到啥情况该做啥也是看大佬们的视频总结出来的，如果有错误的决策轻喷。

在正式介绍卡片操作之前，我们至少还需要两个东西：
1. 条件判定检测函数：我们在放置卡片的时候，需要判定的条件，如果条件不满足则不能种植，这些功能函数包括：小丑爆炸函数，巨人锤击函数，冰车碾压函数，樱桃爆炸函数，红眼粗略IO计算函数等，脚本中将这些函数放置在了类 Judge 中。
2. 得到每行最具威胁的红眼位置函数：此函数会使用红眼粗略IO计算函数来得到红眼是否会被曾哥打死，如果被打死则直接忽略这个红眼。这个函数得到的结果十分重要，垫材，倭瓜，樱桃和辣椒的放置位置都和此函数的结果有关。代码如下
```C++
// 生成有破阵危险的位置列表
void GenDangerGridVec()
{
    static int lock = -1;
    // 一帧只观测一次
    if (lock == AGetMainObject()->GameClock()) {
        return;
    }
    lock = AGetMainObject()->GameClock();
    _dangerGridVec.clear();
    // 第一步：生成最靠左的红眼的位置列表

    // 这里其实开四个内存就够了，开六个内存是为了写的更方便
    // 120 是南瓜头的坐标， 30 是红眼左攻击偏移，80 是南瓜头右防御偏移
    // 40 是我瞎调的
    static std::array<int, 6> leftX = {40, 120 + 30 + 80, -1000, -1000, 120 + 30 + 80, 40};
    _minGigaX = {800, 800, 800, 800, 800, 800};

    for (auto row : {0, 1, 4, 5}) {
        auto futureDamage = row == _jalapenoRow ? 1800 : 0;
        for (int col = 0; col < 7; ++col) {
            auto&& gigaPtrVec = _gigaVec.At2d(row, col);
            if (gigaPtrVec.empty()) {
                continue;
            }
            for (auto gigaPtr : gigaPtrVec) {
                if (Judge::IsGigaIoDead(gigaPtr, futureDamage)) {
                    continue;
                }
                _minGigaX[row] = std::min(_minGigaX[row], gigaPtr->Abscissa() - leftX[row]);
            }
            if (_minGigaX[row] < 800) {
                _dangerGridVec.push_back({row, col});
                break;
            }
        }
    }

    // 第二步：根据坐标对每行的位置进行排序
    std::sort(_dangerGridVec.begin(), _dangerGridVec.end(),
        [this](const AGrid& lhs, const AGrid& rhs) {
            return _minGigaX[lhs.row] < _minGigaX[rhs.row];
        });
}
```

下面正式介绍卡片操作
1. 永久垫材：对于键控来说，这可能没什么难度，有两个思路
 1) 遍历危险位置，如果此位置能够种植，则直接种，如果不能就往后面的格子搜索能种的位置，
实在不能种植就遍历下一个危险位置.
 2) 先遍历所有的危险位置，如果都不能种植则向后扫描，

这两个思路都可以，但是实际脚本中选择第一种，因为第一种代码写起来稍微方便一些，最后种植永久垫材的时候需要检测冰车碾压，巨人锤击和小丑爆炸，面对冰车碾压，采取的策略是遍历下一个危险列表，因为冰车持续时间长，而巨人锤击和小丑爆炸采取的策略是等待他们结束后种植，因为这两个持续时间短。相关代码如下

```C++
// 生成永久垫材的位置
// 包括: 小喷菇
AGrid _GenFodderGrid()
{
    // 遍历危险列表
    // 如果目前危险位置不存在垫材且能种植则直接种植
    // 如果不能种植，则向后面扫描，如果一直不能种植就放弃此行
    // 遍历下一个位置
    for (auto dangerGrid : _dangerGridVec) {
        int minCol = ARangeIn(dangerGrid.row, {2 - 1, 4 - 1}) ? 3 - 1 : 1 - 1;
        do {
            if (_IsPlantable(dangerGrid.row, dangerGrid.col, true)) {
                return dangerGrid;
            }
        } while (--dangerGrid.col > minCol); // 要种植的位置已经太靠左了，放弃种植
    }

    // 如果没有危险位置，就在下面四个位置中依次种植。
    static std::vector<AGrid> gridList = {{1, 3}, {4, 3}, {1, 2}, {4, 2}};
    for (auto&& grid : gridList) {
        if (_IsPlantable(grid.row, grid.col, true)) {
            return grid;
        }
    }
    // 生成失败
    return {-1, -1};
}
```

2. 临时垫材：此类垫材包含寒冰菇和三叶草，使用逻辑是如果目前危险位置不存在垫材且能种植则直接种植，如果不能种植，则遍历下一个位置。
代码十分简单不再展示。但是寒冰菇和三叶草两个植物并不完全相同，当种植寒冰菇的时候，由于其有另一个作用，就是冰杀丑，所以他的种植时间是不能随便等待的，也就是当寒冰菇危险位置不能种植的时候，必须在其他能种植的地方立即种植。而三叶草平时的作用就是吹气球，气球僵尸只要不离家太近就可以等待，所以当危险位置有巨人锤击和小丑爆炸的时候，三叶草就可以等待，除非气球离家太近，这个时候需要不惜一切代价立即使用三叶草。三叶草还有一种情况，就是当红眼离岸路曾特别近的时候，他需要作为垫材使用，也就是通过烧阳光的方式保曾。

3. 辣椒：辣椒的使用方式比较复杂，我们不能在使用辣椒的那一帧遍历僵尸分布情况，因为这样会浪费大量的输出，尤其是倭瓜的输出，辣椒的使用会影响倭瓜樱桃的使用，在脚本中，处理方式为在樱桃辣椒使用波数的第 900cs(也就是冰生效的时刻) 则开始生成辣椒和樱桃的使用半场，具体逻辑就是看岸路对曾哥的威胁和边路对进家的威胁，如果两者都没有威胁，则看樱桃在哪边炸的多，具体如代码所示
```C++
void GenJalapenoAndCherryRow()
{
    if (AGetMainObject()->Wave() == 1) {
        _jalapenoRow = 0;
        return;
    }
    _jalapenoRow = -1;
    Observe();
    GenDangerGridVec();

    if (_dangerGridVec.empty()) {
        _jalapenoRow = 0;
        _cherryRow = 4;
        return;
    }

    // 查看第六列樱桃是否能炸到
    // 第六列樱桃能够炸到第五列以右的红眼
    // 所以直接查看第四列以左有没有红眼
    for (auto&& dangerGrid : _dangerGridVec) {
        if (dangerGrid.row == 1 || dangerGrid.row == 4) {
            // 判断岸路是否快要砸曾，如果要砸曾，要用樱桃炸
            if (_minGigaX[dangerGrid.row] < 80) {
                _jalapenoRow = dangerGrid.row == 1 ? 5 : 0;
                _cherryRow = _jalapenoRow == 0 ? 4 : 0;
                return;
            }
        } else if (dangerGrid.col < 4) { // 边路
            _jalapenoRow = dangerGrid.row;
            _cherryRow = _jalapenoRow == 0 ? 4 : 0;
            return;
        }
    }

    int topGigaCnt = 0;
    int bottomGigaCnt = 0;
    // 边路第四列以左没有红眼，则查看哪边樱桃炸的多
    int leftColOffset = _dangerGridVec.front().col;
    for (int col = 0; col < 5; ++col) {
        for (int row = 0; row < 2; ++row) {
            topGigaCnt += _gigaVec.At2d(row, col + leftColOffset).size();
        }

        for (int row = 4; row < 6; ++row) {
            bottomGigaCnt += _gigaVec.At2d(row, col + leftColOffset).size();
        }
    }

    _jalapenoRow = topGigaCnt > bottomGigaCnt ? 5 : 0;
    _cherryRow = _jalapenoRow == 0 ? 4 : 0;
}
```

上面只是生成了使用半场，辣椒真正使用的时刻是下一波的 266cs，因此咱们还需要一个函数来生成辣椒的使用格子，这个函数就十分简单了，从左向右遍历，遇到第一个血量 > 1800 的红眼直接种植。代码过于简单不再展示

4. 樱桃：实际上有了半场使用位置之后，樱桃的使用方式就简单了，从左向右扫描，遇到 IO 打不死的红眼就直接种植。
5. 倭瓜：有了辣椒樱桃的半场位置之后，倭瓜就优先用在辣椒的旁路，如果辣椒的旁路红眼基本没啥威胁，则依次遍历危险列表，如果没有辣椒的使用半场，那就直接遍历危险列表。
6. 核：核主要是核坑的规划，脚本中的核坑规划为：

```C++
{4, 8}, // wave 2
{3, 7}, // wave 4
{4, 7}, // wave 6
{3, 5}, // wave 8
{3, 4}, // wave 10
{3, 7}, // wave 11
{4, 8}, // wave 13 这波行数待定，需要根据辣椒的使用位置确定，不然会漏橄榄
{4, 7}, // wave 15
{3, 5}, // wave 17
{4, 5}, // wave 19
{3, 7}, // wave 20 这里这个核坑不好
```

别的就没啥了。实际上如果手控的话核坑用的会更灵活，其实键控可能也应该根据场上红眼橄榄的分布情况来放置，但为了简化脚本的编写，这里使用了基本固定的核坑位置，还有要注意的是，第 20 波的核坑会导致下一个flag 的 wave 4 的核无法种植，这是一个需要优化的东西，但是我比较懒，就不优化了。

7. 南瓜头：这个植物没啥好说的，挑一个生命值最低的南瓜直接种植即可，但是需要注意的是，岸路曾的南瓜压力是最大的，因此我为他施加了一个 800 的血量偏移，也就是这两个位置的南瓜被咬成有点损坏的时候，他们的血量就会被 -800(并不是在游戏内存里面-800，而是只在脚本里-800)，以提高他们的修补优先级，这个800是凭感觉设置的，没啥实际意义。南瓜还有一个操作就是铲套，这个东西没什么好说的，看代码就完事了。

卡片操作到这基本就说完了，但是除此之外，我们还需要注意键控和手控不一样的点，那就是键控以帧为单位观测和操作，因此这样只要一些逻辑稍微写的不太好，就会有很多的垫材浪费放置和灰烬输出重叠放置，因此需要采取控制策略，大概的思路就是，当使用非小喷菇的时候，让整个键控检测和操作暂停一段时间，比如，使用了灰烬植物后，整个过程暂停 100cs (脚本中使用了 101cs, 因为我总感觉 100 可能不太稳)。这样能够有效的避免各种浪费，提高成功率，并且代码实现非常简单。还有就是，每波的 2500 - 200 - 100 = 2200cs 咱们需要使用灰烬植物，既然咱们都知道了这个点了，就可以更加提前让电脑暂停操作，脚本中使用了 2000 这个时刻点


## 总结
以上基本就是我对于键控两仪的粗浅理解，本人手控水平几乎为 0，所以其中有些观点肯定有大问题，不过我并不希望大家关注手控思路部分，而是关注如何将自己的看法和想法转换成代码完成键控这个过程，整个脚本耗时 7 天，实际上这个时间很短，脚本很多地方还可以进行更加精细的打磨，这些就留给大家继续完善吧，我相信总有一天，两仪挂机定能实现(如果已经实现了就当我火星)。

[目录](./0catalogue.md)